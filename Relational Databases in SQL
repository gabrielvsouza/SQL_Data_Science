Introduction to relational databases

Investigating universities in Switzerland

A relational database:
  real-life entities become tables 
                                    e.g. professors , universities
  reduced redundancy companies
                                    e.g. only one entry in companies for the bank "Credit Suisse"
  data integrity by relationships 
                                    e.g. a professor can work at multiple universities and companies , 
                                    a company can employ multiple professors
Throughout this course you will:
  work with the data I used for my investigation
  create a relational database from scratch
  learn three concepts:
      constraints
      keys
      referential integrity


Attributes of relational databases
In the video, we talked about some basic facts about relational databases. 
Which of the following statements does not hold true for databases? Relational databases ...
  ... store different real-world entities in different tables.
  ... allow to establish relationships between entities.
  ... are called "relational" because they store data only about people.
  ... use constraints, keys and referential integrity in order to assure data quality.

Your first duty: Have a look at the PostgreSQL database
    SELECT table_schema, table_name
    FROM information_schema.tables;
Have a look at the columns of a certain table
    SELECT table_name, column_name, data_type
    FROM information_schema.columns
    WHERE table_name = 'pg_config';

Query information_schema with SELECT
information_schema is a meta-database that holds information about your current database. information_schema has 
multiple tables you can query with the known SELECT * FROM syntax:
    tables: information about all tables in your current database
    columns: information about all columns in all of the tables in your current database
    ...
In this exercise, you'll only need information from the 'public' schema, which is specified as the column table_schema 
of the tables and columns tables. The 'public' schema holds information about user-defined tables and databases. 
The other types of table_schema hold system information – for this course, you're only interested in user-defined stuff.
Get information on all table names in the current database, while limiting your query to the 'public' table_schema
    -- Query the right table in information_schema
    SELECT table_name 
    FROM information_schema.tables
    -- Specify the correct table_schema value
    WHERE table_schema = 'public';
    
Tables: At the core of every database  
Redundancy in the university_professors table
    SELECT * FROM
    FROM university_professors
    LIMIT 3;

Now have a look at the columns in university_professors by selecting all entries in information_schema.columns that 
correspond to that table.
    -- Query the right table in information_schema to get columns
    SELECT column_name, data_type 
    FROM information_schema.columns
    WHERE table_name = 'university_professors' AND table_schema = 'public';
How many columns does the table university_professors have?
    # columns
    SELECT COUNT(*)
    FROM information_schema.columns
    WHERE table_name = 'university_professors'
    # lines
    SELECT COUNT(*) 
    FROM university_professors 
Finally, print the first five rows of the university_professors table.
    -- Query the first five rows of our table
    SELECT * 
    FROM university_professors 
    LIMIT 5;
You're now familiar with the pre-existing university_professors table, which holds information on all kinds of entities. 
You'll migrate data from this table to other tables in the upcoming lessons

Currently: One "entity type" in the database
A better database model with three entity types
A better database model with four entity types


Create new tables with CREATE TABLE
CREATE your first few TABLEs
You'll now start implementing a better database model. For this, you'll create tables for the professors and 
universities entity types. The other tables will be created for you.
The syntax for creating simple tables is as follows:
    CREATE TABLE table_name (
     column_a data_type,
     column_b data_type,
     column_c data_type
    );
Attention: Table and columns names, as well as data types, don't need to be surrounded by quotation marks.
Create a table professors with two text columns: firstname and lastname
    -- Create a table for the professors entity type
    CREATE TABLE professors (
     firstname text,
     lastname text
    );
    -- Print the contents of this table
    SELECT * 
    FROM professors
Create a table universities with three text columns: university_shortname, university, and university_city
    -- Create a table for the universities entity type
    CREATE TABLE universities (
        university_shortname text,
        university text,
        university_city text
    );
    -- Print the contents of this table
    SELECT * 
    FROM universities
The other two tables, affiliations and organizations, will be created for you


ADD a COLUMN with ALTER TABLE
Oops! We forgot to add the university_shortname column to the professors table. You've probably already noticed:
In chapter 4 of this course, you'll need this column for connecting the professors table with the universities table.
However, adding columns to existing tables is easy, especially if they're still empty.
To add columns you can use the following SQL query:
    ALTER TABLE table_name
    ADD COLUMN column_name data_type;
Alter professors to add the text column university_shortname
    -- Add the university_shortname column
    ALTER TABLE professors
    ADD COLUMN university_shortname text;
    -- Print the contents of this table
    SELECT * 
    FROM professors


Update your database as the structure changes
  The current database model
  Migrate data
Only store DISTINCT data in the new tables
    SELECT COUNT(*)
    FROM university_professors;
 1377
    SELECT COUNT(DISTINCT organization)
    FROM university_professors;
1287
#
INSERT DISTINCT records INTO the new tables
      INSERT INTO organizations
      SELECT DISTINCT organization,
          organization_sector
      FROM university_professors; 
Output: INSERT 0 1287
      INSERT INTO organizations
      SELECT organization,
          organization_sector
      FROM university_professors;
Output: INSERT 0 1377
#
The INSERT INTO statement
    INSERT INTO table_name (column_a, column_b)
    VALUES ("value_a", "value_b");
#
RENAME a COLUMN in affiliations
    CREATE TABLE affiliations (
    firstname text,
    lastname text,
    university_shortname text,
    function text,
    organisation text
    );
ALTER TABLE table_name
RENAME COLUMN old_name TO new_name;
#
DROP a COLUMN in affiliations
    CREATE TABLE affiliations (
    firstname text,
    lastname text,
    university_shortname text,
    function text,
    organization text
    );
ALTER TABLE table_name
DROP COLUMN column_name;
#
A professor is uniquely identified by firstname, lastname only
    SELECT DISTINCT firstname, lastname,
    university_shortname
    FROM university_professors
    ORDER BY lastname;
-[ RECORD 1 ]--------+-------------
firstname| Karl
lastname| Aberer
university_shortname | EPF
-[ RECORD 2 ]--------+-------------
firstname| Reza Shokrollah
lastname| Abhari
university_shortname | ETH
-[ RECORD 3 ]--------+-------------
firstname| Georges
lastname| Abou Jaoudé
university_shortname | EPF
(truncated)
(551 records)
    SELECT DISTINCT firstname, lastname
    FROM university_professors
    ORDER BY lastname;
-[ RECORD 1 ]--------+-------------
firstname| Karl
lastname| Aberer
-[ RECORD 2 ]--------+-------------
firstname| Reza Shokrollah
lastname| Abhari
-[ RECORD 3 ]--------+-------------
firstname| Georges
lastname| Abou Jaoudé
(truncated)
(551 records)

RENAME and DROP COLUMNs in affiliations
As mentioned in the video, the still empty affiliations table has some flaws. In this exercise, you'll correct 
them as outlined in the video.
You'll use the following queries:
To rename columns:
    ALTER TABLE table_name
    RENAME COLUMN old_name TO new_name;
To delete columns:
    ALTER TABLE table_name
    DROP COLUMN column_name;
Rename the organisation column to organization in affiliations
    ALTER TABLE affiliations
    RENAME COLUMN organisation TO organization;
Delete the university_shortname column in affiliations
    ALTER TABLE affiliations
    DROP COLUMN university_shortname;
Now the tables are finally ready for data migration

Migrate data with INSERT INTO SELECT DISTINCT
Now it's finally time to migrate the data into the new tables. You'll use the following pattern:
    INSERT INTO ... 
    SELECT DISTINCT ... 
    FROM ...;
It can be broken up into two parts:
First part:
    SELECT DISTINCT column_name1, column_name2, ... 
    FROM table_a;
This selects all distinct values in table table_a – nothing new for you.
Second part:
  INSERT INTO table_b ...;
Take this part and append it to the first, so it inserts all distinct rows from table_a into table_b.
One last thing: It is important that you run all of the code at the same time once you have filled out the blanks.
Insert all DISTINCT professors from university_professors into professors.
Print all the rows in professors.
    INSERT INTO professors 
    SELECT DISTINCT firstname, lastname, university_shortname 
    FROM university_professors;
    -- Doublecheck the contents of professors
    SELECT * 
    FROM professors;
Insert all DISTINCT affiliations into affiliations.
    -- Insert unique affiliations into the new table
    INSERT INTO affiliations 
    SELECT DISTINCT firstname, lastname, function, organization 
    FROM university_professors;
    -- Doublecheck the contents of affiliations
    SELECT * 
    FROM affiliations;
You can see that there are 1377 distinct combinations of professors and organisations in the dataset. 

Delete tables with DROP TABLE
Obviously, the university_professors table is now no longer needed and can safely be deleted.
For table deletion, you can use the simple command:
    DROP TABLE table_name;
Delete the university_professors table
    DROP TABLE university_professors;

###
### Better data quality with constraints
###
Integrity constraints
  1. Attribute constraints, e.g. data types on columns (Chapter 2)
  2. Key constraints, e.g. primary keys (Chapter 3)
  3. Referential integrity constraints, enforced through foreign keys (Chapter 4)
Why constraints?
  Constraints give the data structure
  Constraints help with consistency, and thus data quality
  Data quality is a business advantage / data science prerequisite
  Enforcing is difficult, but PostgreSQL helps
Data types as attribute constraints
  From the PostgreSQL documentation
Dealing with data types (casting)
    CREATE TABLE weather (
    temperature integer,
    wind_speed text);
#
    SELECT temperature * wind_speed AS wind_chill
    FROM weather;
operator does not exist: integer * text
HINT: No operator matches the given name and argument type(s).
You might need to add explicit type casts.
    SELECT temperature * CAST(wind_speed AS integer) AS wind_chill
    FROM weather;


Conforming with data types
For demonstration purposes, I created a fictional database table that only holds three records. 
The columns have the data types date, integer, and text, respectively.
    CREATE TABLE transactions (
     transaction_date date, 
     amount integer,
     fee text
    );
Have a look at the contents of the transactions table.
The transaction_date accepts date values. According to the PostgreSQL documentation, it accepts values in the 
form of YYYY-MM-DD, DD/MM/YY, and so forth.
https://www.postgresql.org/docs/10/datatype-datetime.html#DATATYPE-DATETIME-INPUT
Both columns amount and fee appear to be numeric, however, the latter is modeled as text – which you will 
account for in the next exercise.
    Execute the given sample code.
    -- Let's add a record to the table
    INSERT INTO transactions (transaction_date, amount, fee) 
    VALUES ('2018-24-09', 5454, '30');
    -- Doublecheck the contents
    SELECT *
    FROM transactions;
  date/time field value out of range: "2018-24-09"
  LINE 3: VALUES ('2018-24-09', 5454, '30');
As it doesn't work, have a look at the error message and correct the statement accordingly – then execute it again.
    INSERT INTO transactions (transaction_date, amount, fee) 
    VALUES ('2018-09-24', 5454, '30');
    SELECT *
    FROM transactions;
 Data types provide certain restrictions on how data can be entered into a table. 
 This may be tedious at the moment of insertion, but saves a lot of headache in the long run.


Type CASTs
In the video, you saw that type casts are a possible solution for data type issues. 
If you know that a certain column stores numbers as text, you can cast the column to a numeric form, i.e. to integer.
    SELECT CAST(some_column AS integer)
    FROM table;
Now, the some_column column is temporarily represented as integer instead of text, meaning that you can perform 
numeric calculations on the column.
Execute the given sample code.
    - Calculate the net amount as amount + fee
    SELECT transaction_date, amount + fee AS net_amount 
    FROM transactions;
  operator does not exist: integer + text
  LINE 2: SELECT transaction_date, amount + fee AS net_amount                                        ^
  HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
As it doesn't work, add an integer type cast at the right place and execute it again.
    SELECT transaction_date, amount + CAST(fee AS integer) AS net_amount 
    FROM transactions;
type casts are necessary to work with data. However, it is better to store columns in the right data type 
from the first place


Working with data types
  Enforced on columns (i.e. attributes)
  Define the so-called "domain" of a column
  Define what operations are possible
  Enfore consistent storage of values
The most common types
  text : character strings of any length
  varchar [ (x) ] : a maximum of n characters
  char [ (x) ] : a fixed-length string of n characters
  boolean : can only take three states, e.g. TRUE , FALSE and NULL (unknown)
  date , time and timestamp : various formats for date and time calculations
  numeric : arbitrary precision numbers, e.g. 3.1457
  integer : whole numbers in the range of -2147483648 and +2147483647
      From the PostgreSQL documentation .
Specifying types upon table creation
    CREATE TABLE students (
    ssn integer,
    name varchar(64),
    dob date,
    average_grade numeric(3, 2), -- e.g. 5.54
    tuition_paid boolean
    );
Alter types after table creation
    ALTER TABLE students
    ALTER COLUMN name
    TYPE varchar(128);
    ALTER TABLE students
    ALTER COLUMN average_grade
    TYPE integer
    -- Turns 5.54 into 6, not 5, before type conversion
    USING ROUND(average_grade);


Change types with ALTER COLUMN
The syntax for changing the data type of a column is straightforward. 
The following code changes the data type of the column_name column in table_name to varchar(10):
    ALTER TABLE table_name
    ALTER COLUMN column_name
    TYPE varchar(10)
Now it's time to start adding constraints to your database.
Have a look at the distinct university_shortname values and take note of the length of the strings.
    SELECT DISTINCT(university_shortname) 
    FROM professors;
Now specify a fixed-length character type with the correct length for university_shortname.
    ALTER TABLE professors
    ALTER COLUMN university_shortname
    TYPE char(3);
Change the type of the firstname column to varchar(64).
    ALTER TABLE professors
    ALTER COLUMN firstname
    TYPE varchar(64);


Convert types USING a function
If you don't want to reserve too much space for a certain varchar column, you can truncate the values before 
converting its type.
For this, you can use the following syntax:
    ALTER TABLE table_name
    ALTER COLUMN column_name
    TYPE varchar(x)
    USING SUBSTRING(column_name FROM 1 FOR x)
You should read it like this: Because you want to reserve only x characters for column_name, 
you have to retain a SUBSTRING of every value, i.e. the first x characters of it, and throw away the rest. 
This way, the values will fit the varchar(x) requirement.
Run the sample code as is and take note of the error.
    -- Convert the values in firstname to a max. of 16 characters
    ALTER TABLE professors 
    ALTER COLUMN firstname 
    TYPE varchar(16)
  value too long for type character varying(16)
Now use SUBSTRING() to reduce firstname to 16 characters so its type can be altered to varchar(16).
    ALTER TABLE professors 
    ALTER COLUMN firstname 
    TYPE varchar(16)
    USING SUBSTRING(firstname FROM 1 FOR 16)
However, it's best not to truncate any values in your database, so we'll revert this column to varchar(64)


The not-null and unique constraints
The not-null constraint
  Disallow NULL values in a certain column
  Must hold true for the current state
  Must hold true for any future state
What does NULL mean?
  unknown
  does not exist
  does not apply
  ...
What does NULL mean? An example
    CREATE TABLE students (
    ssn integer not null,
    lastname varchar(64) not null,
    home_phone integer,
    office_phone integer
    );
NULL != NULL
How to add or remove a not-null constraint
When creating a table...
    CREATE TABLE students (
    ssn integer not null,
    lastname varchar(64) not null,
    home_phone integer,
    office_phone integer
    );
After the table has been created...
    ALTER TABLE students
    ALTER COLUMN home_phone
    SET NOT NULL;
    ALTER TABLE students
    ALTER COLUMN ssn
    DROP NOT NULL;
The unique constraint
  Disallow duplicate values in a column
  Must hold true for the current state
  Must hold true for any future state
Adding unique constraints
    CREATE TABLE table_name (
    column_name UNIQUE
    );
    #
    ALTER TABLE table_name
    ADD CONSTRAINT some_name UNIQUE(column_name);


Disallow NULL values with SET NOT NULL
The professors table is almost ready now. However, it still allows for NULLs to be entered. 
Although some information might be missing about some professors, there's certainly columns that always need to be specified.
Add a not-null constraint for the firstname column.
    ALTER TABLE professors 
    ALTER COLUMN firstname 
    SET NOT NULL;
Add a not-null constraint for the lastname column.
    ALTER TABLE professors 
    ALTER COLUMN lastname 
    SET NOT NULL;
It is no longer possible to add professors which have either their first or last name set to NULL. 
Likewise, it is no longer possible to update an existing professor and setting their first or last name to NULL

What happens if you try to enter NULLs?
Execute the following statement:
    INSERT INTO professors (firstname, lastname, university_shortname)
    VALUES (NULL, 'Miller', 'ETH');
Why does this throw an error?
Possible Answers
  Professors without first names do not exist.
  Because a database constraint is violated.
  Error? This works just fine.
  NULL is not put in quotes.
This statement violates one of the not-null constraints you've just specified.


Make your columns UNIQUE with ADD CONSTRAINT
As seen in the video, you add the UNIQUE keyword after the column_name that should be unique. 
This, of course, only works for new tables:
    CREATE TABLE table_name (
     column_name UNIQUE
    );
If you want to add a unique constraint to an existing table, you do it like that:
    ALTER TABLE table_name
    ADD CONSTRAINT some_name UNIQUE(column_name);
Note that this is different from the ALTER COLUMN syntax for the not-null constraint. 
Also, you have to give the constraint a name some_name.
Add a unique constraint to the university_shortname column in universities. 
Give it the name university_shortname_unq.
    -- Make universities.university_shortname unique
    ALTER TABLE universities
    ADD CONSTRAINT university_shortname_unq UNIQUE(university_shortname);
Add a unique constraint to the organization column in organizations. 
Give it the name organization_unq.
    -- Make organizations.organization unique
    ALTER TABLE organizations
    ADD CONSTRAINT organization_unq UNIQUE(organization);
Making sure universities.university_shortname and organizations.organization only contain unique values
is a prerequisite for turning them into so-called primary keys – the subject of the next chapter!

###
### Keys and superkeys
###
























